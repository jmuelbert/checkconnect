# SPDX-License-Identifier: EUPL-1.2
#
# SPDX-FileCopyrightText: © 2025-present Jürgen Mülbert

"""
CheckConnect Report Generator Module.

This module manages the generation of HTML and PDF reports from NTP and URL test results.
It provides functionality to create reports using a customizable HTML template and
to generate PDF reports using WeasyPrint.
It is designed to work with the CheckConnect application context, which
includes configuration, logging, and translation capabilities.
"""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any, Final

import structlog
from platformdirs import user_data_dir
from pydantic import BaseModel, ValidationError, ValidationInfo, field_validator
from weasyprint import HTML

from checkconnect import __about__
from checkconnect.exceptions import DirectoryCreationError, ReportsMissingDataError

if TYPE_CHECKING:
    from collections.abc import Callable

    from structlog.stdlib import BoundLogger

    from checkconnect.config.appcontext import AppContext
    from checkconnect.config.translation_manager import TranslationManager

# Global logger for main.py (will be reconfigured by LoggingManagerSingleton)
log: structlog.stdlib.BoundLogger
log = structlog.get_logger(__name__)


class ReportTemplate:
    """
    A template for generating CheckConnect reports.

    This template provides a standard HTML layout with sections for NTP and URL results.
    """

    TEMPLATE: Final[str] = """<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{title}</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    line-height: 1.5;
                    color: #333;
                }}
                h1 {{
                    color: #2c3e50;
                    border-bottom: 2px solid #eee;
                    padding-bottom: 10px;
                }}
                h2 {{
                    color: #16a085;
                    margin-top: 25px;
                }}
                pre {{
                    background-color: #f7f7f7;
                    padding: 15px;
                    border-radius: 5px;
                    border-left: 4px solid #16a085;
                    white-space: pre-wrap;
                    font-family: monospace;
                    overflow-x: auto;
                }}
                .container {{
                    max-width: 1000px;
                    margin: 0 auto;
                }}
                .footer {{
                    margin-top: 30px;
                    padding-top: 10px;
                    border-top: 1px solid #eee;
                    font-size: 0.8em;
                    color: #777;
                    text-align: center;
                }}
                @media print {{
                    body {{
                        font-size: 11pt;
                    }}
                    pre {{
                        border-left: 2px solid #16a085;
                        padding: 10px;
                    }}
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>{title}</h1>
                <h2>{ntp_header}</h2>
                <pre>{ntp_content}</pre>
                <h2>{url_header}</h2>
                <pre>{url_content}</pre>
                <div class="footer">
                    Generated by CheckConnect
                </div>
            </div>
        </body>
        </html>
    """

    def __init__(
        self,
        title: str | None = None,
        ntp_header: str | None = None,
        url_header: str | None = None,
    ) -> None:
        """
        Initialize the template with customizable titles and headers.

        Args:
        ----
            title: Title of the report. Defaults to "CheckConnect Report".
            ntp_header: Header for the NTP section. Defaults to "NTP Results".
            url_header: Header for the URL section. Defaults to "URL Results".
        """
        self.title: str = title or "CheckConnect Report"
        self.ntp_header: str = ntp_header or "NTP Results"
        self.url_header: str = url_header or "URL Results"

    def render(self, ntp_content: str, url_content: str) -> str:
        """
        Render the report template with the provided data.

        Args:
        ----
            ntp_content: The NTP results content to include in the report.
            url_content: The URL results content to include in the report.

        Returns:
        -------
            A rendered HTML string containing the complete report.
        """
        return self.TEMPLATE.format(
            title=self.title,
            ntp_header=self.ntp_header,
            url_header=self.url_header,
            ntp_content=ntp_content,
            url_content=url_content,
        )


class ReportInput(BaseModel):
    """
    Pydantic model for validating report input data.

    Ensures that NTP and URL results are provided as non-empty lists of strings.
    """

    ntp_results: list[str]
    url_results: list[str]

    @field_validator("ntp_results", "url_results")
    @classmethod
    def check_not_empty(cls, v: list[str], info: ValidationInfo) -> list[str]:
        """
        Validate to ensure the list fields are not empty.

        Args:
        ----
            v: The list to validate.
            info: Validation information provided by Pydantic.

        Returns:
        -------
            The validated list.

        Raises:
        ------
            ValueError: If the list is empty.
        """
        if not v:
            msg = f"Field '{info.field_name}' cannot be empty."
            raise ValueError(msg)
        return v

    @field_validator("ntp_results", "url_results", mode="before")
    @classmethod
    def ensure_list_of_strings(cls, v: Any) -> list[str]:
        """
        Validate to ensure the input is a list of strings before other validations.

        This validator runs in 'before' mode to pre-process or validate the type
        before Pydantic's default validation.

        Args:
        ----
            v: The input value to validate.

        Returns:
        -------
            The validated list of strings.

        Raises:
        ------
            ValueError: If the input is not a list or if any item in the list is not a string.
        """
        # Pydantic's core validation for `list[str]` will handle non-list types
        # and non-string elements if this validator does not explicitly raise.
        # However, for clarity and specific error messages, we can add checks here.
        if not isinstance(v, list):
            # Pydantic will typically raise a TypeError for `list[str]` if `v` isn't a list.
            # Raising a ValueError here provides a more specific error message.
            msg = "Input must be a list."
            raise ValueError(msg)  # noqa: TRY004

        if not all(isinstance(item, str) for item in v):
            msg = "All items in the list must be strings."
            raise ValueError(msg)

        return v


class ReportGenerator:
    """
    Generates HTML and PDF reports from NTP and URL test results.

    This class provides functionality to create both HTML and PDF reports
    from the results of NTP server and URL connectivity tests. It integrates
    with the application context for configuration, logging, and internationalization.
    """

    HTML_FILENAME: Final[str] = "report.html"
    PDF_FILENAME: Final[str] = "report.pdf"

    context: AppContext
    logger: BoundLogger
    translator: TranslationManager
    reports_dir: Path

    # Type definition for the translation function
    _translate_func: Callable[[str], str]

    def __init__(
        self,
        context: AppContext,
        reports_dir: Path,
    ) -> None:
        """
        Initialize the ReportGenerator with the application context and output directory.

        Args:
        ----
            context: The application context containing configuration, logger, and translator.
            reports_dir: The directory to store the generated reports.
        """
        self.context = context
        self.translator = context.translator
        self._translate_func = context.translator.gettext
        self.reports_dir = reports_dir

        # Ensure the directory exists
        try:
            self.reports_dir.mkdir(parents=True, exist_ok=True)
            log.debug(self._translate_func("Ensured report directory exists."), path=str(self.reports_dir))
        except OSError as e:
            log.exception(
                self._translate_func("Failed to create report directory."), path=str(self.reports_dir), exc_info=e
            )
            # Depending on severity, you might want to raise an exception or handle gracefully
            msg = self._translate_func(f"Failed to create report directory: '{reports_dir}': {e}")
            raise DirectoryCreationError(message=msg, original_exception=e) from e

    # --- Factory-Methods ---
    @classmethod
    def from_context(cls, context: AppContext) -> ReportGenerator:
        """
        Create a ReportGenerator.

        Using the configuration file's report directory
        or a default user data directory if not specified in config.

        Args:
            context: The application context containing config, logger, and translator.

        Returns:
            A configured ReportGenerator instance.
        """
        # The default value for get should be the most robust and standard path
        app_name = (__about__.__app_name__).lower()
        app_org_id = (__about__.__app_org_id__).lower()
        default_reports_path = Path(user_data_dir(app_name, app_org_id))

        reports_dir_from_config_str: str | None = context.settings.get("reports", "directory")

        if reports_dir_from_config_str:
            reports_dir = Path(reports_dir_from_config_str)
            log.info(
                context.translator.translate("Using report directory from config."),
                reports_dir=reports_dir,
            )
        else:
            reports_dir = default_reports_path
            log.warning(
                context.translator.translate(
                    "Report directory not found in config or invalid. Using default."),
                    path=str(reports_dir)
            )

        return cls(context=context, reports_dir=reports_dir)

    @classmethod
    def from_params(cls, context: AppContext, arg_reports_dir: Path) -> ReportGenerator:
        """
        Create a ReportGenerator.

        Prioritizing a provided argument path.
        If the argument is None, it falls back to from_context to get the path
        from config or default.

        Args:
            context: The application context containing config, logger, and translator.
            arg_reports_dir: The directory path provided as a command-line argument (can be None).

        Returns:
            A configured ReportGenerator instance.
        """
        if arg_reports_dir is not None:
            # An argument was provided, always use it.
            log.info(
                context.translator.translate("Using report directory from CLI argument."),
                reports_dir=arg_reports_dir,
            )
            return cls(context=context, reports_dir=arg_reports_dir)
        # No argument provided, fall back to logic in from_context
        log.debug(
            context.translator.translate("No report directory argument provided. Falling back to config/default.")
        )
        return cls.from_context(context)

    def _validate_results(self, ntp_results: list[str], url_results: list[str]) -> None:
        """
        Validate the NTP and URL results before generating reports.

        Args:
        ----
            ntp_results: A list of NTP test results (strings).
            url_results: A list of URL test results (strings).

        Raises:
        ------
            ReportsMissingDataError: If both ntp_results and url_results are empty.
            TypeError: If ntp_results or url_results are not lists of strings.
        """
        if not ntp_results and not url_results:
            msg = self._translate_func("Cannot generate a report. No results provided")
            log.error(msg)
            raise ReportsMissingDataError(msg)

        if not all(isinstance(item, str) for item in ntp_results):
            msg = self._translate_func("Invalid NTP results: Expected list of strings")
            log.error(msg)
            raise TypeError(msg)

        if not all(isinstance(item, str) for item in url_results):
            msg = self._translate_func("Invalid URL results: Expected list of strings")
            log.error(msg)
            raise TypeError(msg)

    def generate_report(self, validated_data: ReportInput, report_filename: str = "report.txt") -> Path:
        """
        Generate a physical report based on validated data.

        This method creates a simple text report containing the NTP and URL results.

        Args:
        ----
            validated_data: An instance of `ReportInput` with already validated data.
            report_filename: The name of the report file to be created. Defaults to "report.txt".

        Returns:
        -------
            The path to the created report file.
        """
        report_path = self.reports_dir / report_filename
        with report_path.open("w", encoding="utf-8") as f:
            f.write(self._translate_func("Connectivity Report\n\n"))
            f.write(self._translate_func("NTP Results:\n"))
            if validated_data.ntp_results:
                for result in validated_data.ntp_results:
                    f.write(f"- {result}\n")
            else:
                f.write(self._translate_func("- No NTP results.\n"))

            f.write(self._translate_func("URL Results:\n"))
            if validated_data.url_results:
                for result in validated_data.url_results:
                    f.write(f"- {result}\n")
            else:
                f.write(self._translate_func("- No URL results.\n"))
        log.info(self._translate_func("Report saved"), path=str(report_path))
        return report_path

    def generate_reports(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> None:
        """
        Generate both HTML and PDF reports from NTP and URL test results.

        Args:
        ----
            ntp_results: A list of NTP check results.
            url_results: A list of URL check results.
        """
        log.info(self._translate_func("Generating reports"), path=str(self.reports_dir))

        self.generate_html_report(
            ntp_results=ntp_results,
            url_results=url_results,
        )

        self.generate_pdf_report(
            ntp_results=ntp_results,
            url_results=url_results,
        )

    def generate_html_report(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> Path:
        """
        Generate an HTML report from NTP and URL test results.

        Args:
        ----
            ntp_results: List of NTP check results (strings).
            url_results: List of URL check results (strings).

        Returns:
        -------
            Path to the generated HTML report.

        Raises:
        ------
            ValidationError: If the input data fails Pydantic validation.
            OSError: If there is an error writing the HTML file.
            Exception: For any other unexpected errors during report generation.
        """
        log.info(
            self._translate_func("Creating HTML report with NTP servers and URLs."),
            path=str(self.reports_dir),
        )

        try:
            ReportInput(ntp_results=ntp_results, url_results=url_results)
        except ValidationError as e:
            msg = self._translate_func("Invalid report data.")
            log.exception(msg, exc_info=e)
            raise

        try:
            ntp_content = "\n".join(ntp_results)
            url_content = "\n".join(url_results)

            # Instantiate the template and render the HTML
            report_template = ReportTemplate()
            html_content = report_template.render(ntp_content, url_content)

            # Ensure output directory exists and write the HTML content
            output_path = self.reports_dir / self.HTML_FILENAME
            output_path.write_text(html_content, encoding="utf-8")

            log.info(self._translate_func("HTML reports generated."), path=str(output_path))

        except (OSError, Exception) as e:
            log.exception(self._translate_func("Error generating HTML report."), exc_info=e)
            raise
        else:
            return output_path

    def generate_pdf_report(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> Path:
        """
        Generate a PDF report from NTP and URL test results.

        Args:
        ----
            ntp_results: List of NTP check results (strings).
            url_results: List of URL check results (strings).

        Returns:
        -------
            Path to the generated PDF report.

        Raises:
        ------
            ValidationError: If the input data fails Pydantic validation.
            Exception: For any errors during PDF generation via WeasyPrint.
        """
        log.info(self._translate_func("Creating PDF report with NTP servers and URLs."), path=str(self.reports_dir))

        try:
            ReportInput(ntp_results=ntp_results, url_results=url_results)
        except ValidationError as e:
            msg = self._translate_func("Invalid report data.")
            log.exception(msg, exc_info=e)
            raise

        try:
            ntp_content = "\n".join(ntp_results)
            url_content = "\n".join(url_results)

            # Instantiate the template and render the HTML
            report_template = ReportTemplate()
            html_content = report_template.render(ntp_content, url_content)

            output_path = self.reports_dir / self.PDF_FILENAME

            # Generate the PDF
            HTML(string=html_content).write_pdf(str(output_path))

            log.info(self._translate_func("PDF reports generated."), path=str(output_path))

        except Exception as e:
            log.exception(self._translate_func("Error generating PDF report."), exc_info=e)
            raise
        else:
            return output_path


def generate_html_report(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate an HTML report from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_html_report(ntp_results, url_results)


def generate_pdf_report(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate a PDF report from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_pdf_report(ntp_results, url_results)


def generate_reports(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate both HTML and PDF reports from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_html_report(ntp_results, url_results)
    report_generator.generate_pdf_report(ntp_results, url_results)
