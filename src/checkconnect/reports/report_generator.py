# SPDX-License-Identifier: EUPL-1.2
#
# SPDX-FileCopyrightText: © 2025-present Jürgen Mülbert

"""
CheckConnect Report Generator Module.

This module manages the generation of HTML and PDF reports from NTP and URL test results.
It provides functionality to create reports using a customizable HTML template and
to generate PDF reports using WeasyPrint.
It is designed to work with the CheckConnect application context, which
includes configuration, logging, and translation capabilities.
"""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any, Final

import structlog
from pydantic import BaseModel, ValidationError, ValidationInfo, field_validator
from weasyprint import HTML

from checkconnect.exceptions import DirectoryCreationError, ReportsMissingDataError

if TYPE_CHECKING:
    from structlog.stdlib import BoundLogger

    from checkconnect.config.appcontext import AppContext
    from checkconnect.config.translation_manager import TranslationManager

log: BoundLogger = structlog.get_logger(__name__)


class ReportTemplate:
    """
    A template for generating CheckConnect reports.

    This template provides a standard HTML layout with sections for NTP and URL results.
    """

    TEMPLATE: Final[str] = """<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{title}</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    margin: 20px;
                    line-height: 1.5;
                    color: #333;
                }}
                h1 {{
                    color: #2c3e50;
                    border-bottom: 2px solid #eee;
                    padding-bottom: 10px;
                }}
                h2 {{
                    color: #16a085;
                    margin-top: 25px;
                }}
                pre {{
                    background-color: #f7f7f7;
                    padding: 15px;
                    border-radius: 5px;
                    border-left: 4px solid #16a085;
                    white-space: pre-wrap;
                    font-family: monospace;
                    overflow-x: auto;
                }}
                .container {{
                    max-width: 1000px;
                    margin: 0 auto;
                }}
                .footer {{
                    margin-top: 30px;
                    padding-top: 10px;
                    border-top: 1px solid #eee;
                    font-size: 0.8em;
                    color: #777;
                    text-align: center;
                }}
                @media print {{
                    body {{
                        font-size: 11pt;
                    }}
                    pre {{
                        border-left: 2px solid #16a085;
                        padding: 10px;
                    }}
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>{title}</h1>
                <h2>{ntp_header}</h2>
                <pre>{ntp_content}</pre>
                <h2>{url_header}</h2>
                <pre>{url_content}</pre>
                <div class="footer">
                    Generated by CheckConnect
                </div>
            </div>
        </body>
        </html>
    """

    def __init__(
        self,
        title: str | None = None,
        ntp_header: str | None = None,
        url_header: str | None = None,
    ) -> None:
        """
        Initialize the template with customizable titles and headers.

        Args:
        ----
            title: Title of the report. Defaults to "CheckConnect Report".
            ntp_header: Header for the NTP section. Defaults to "NTP Results".
            url_header: Header for the URL section. Defaults to "URL Results".
        """
        self.title: str = title or "CheckConnect Report"
        self.ntp_header: str = ntp_header or "NTP Results"
        self.url_header: str = url_header or "URL Results"

    def render(self, ntp_content: str, url_content: str) -> str:
        """
        Render the report template with the provided data.

        Args:
        ----
            ntp_content: The NTP results content to include in the report.
            url_content: The URL results content to include in the report.

        Returns:
        -------
            A rendered HTML string containing the complete report.
        """
        return self.TEMPLATE.format(
            title=self.title,
            ntp_header=self.ntp_header,
            url_header=self.url_header,
            ntp_content=ntp_content,
            url_content=url_content,
        )


class ReportInput(BaseModel):
    """
    Pydantic model for validating report input data.

    Ensures that NTP and URL results are provided as non-empty lists of strings.
    """

    ntp_results: list[str]
    url_results: list[str]

    @field_validator("ntp_results", "url_results")
    @classmethod
    def check_not_empty(cls, v: list[str], info: ValidationInfo) -> list[str]:
        """
        Validator to ensure the list fields are not empty.

        Args:
        ----
            v: The list to validate.
            info: Validation information provided by Pydantic.

        Returns:
        -------
            The validated list.

        Raises:
        ------
            ValueError: If the list is empty.
        """
        if not v:
            msg = f"Field '{info.field_name}' cannot be empty."
            raise ValueError(msg)
        return v

    @field_validator("ntp_results", "url_results", mode="before")
    @classmethod
    def ensure_list_of_strings(cls, v: Any) -> list[str]:
        """
        Validator to ensure the input is a list of strings before other validations.

        This validator runs in 'before' mode to pre-process or validate the type
        before Pydantic's default validation.

        Args:
        ----
            v: The input value to validate.

        Returns:
        -------
            The validated list of strings.

        Raises:
        ------
            ValueError: If the input is not a list or if any item in the list is not a string.
        """
        # Pydantic's core validation for `list[str]` will handle non-list types
        # and non-string elements if this validator does not explicitly raise.
        # However, for clarity and specific error messages, we can add checks here.
        if not isinstance(v, list):
            # Pydantic will typically raise a TypeError for `list[str]` if `v` isn't a list.
            # Raising a ValueError here provides a more specific error message.
            msg = "Input must be a list."
            raise ValueError(msg)  # noqa: TRY004

        if not all(isinstance(item, str) for item in v):
            msg = "All items in the list must be strings."
            raise ValueError(msg)

        return v


class ReportGenerator:
    """
    Generates HTML and PDF reports from NTP and URL test results.

    This class provides functionality to create both HTML and PDF reports
    from the results of NTP server and URL connectivity tests. It integrates
    with the application context for configuration, logging, and internationalization.
    """

    HTML_FILENAME: Final[str] = "report.html"
    PDF_FILENAME: Final[str] = "report.pdf"
    context: AppContext
    logger: BoundLogger
    translator: TranslationManager
    output_dir: Path
    _: Any  # Placeholder for gettext function

    def __init__(
        self,
        context: AppContext,
        output_dir: Path,
    ) -> None:
        """
        Initialize the ReportGenerator with the application context and output directory.

        Args:
        ----
            context: The application context containing configuration, logger, and translator.
            output_dir: The directory to store the generated reports.
        """
        self.context = context
        self.logger = log
        self.translator = context.translator
        self._ = self.translator.gettext
        self.output_dir = output_dir

    # --- Factory-Methods ---
    @classmethod
    def from_context(cls, context: AppContext) -> ReportGenerator:
        """
        Create a ReportGenerator from an application context.

        Args:
        ----
            context: The application context containing config, logger, and translator.

        Returns:
        -------
            A configured ReportGenerator instance.

        Raises:
        ------
            ValueError: If the report directory is not found in the configuration.
        """
        output_dir: Path
        output_dir_str: str | None = context.config.get("reports", "directory", "reports")
        if output_dir_str is None:
            log.error(
                context.translator.translate(
                    "Report directory not found in config. Using default reports directory as default"
                )
            )
            output_dir_str = "reports"

        output_dir = Path(output_dir_str)

        instance = cls(context=context, output_dir=output_dir)
        instance._ensure_output_directory(output_dir)  # noqa: SLF001
        return instance

    @classmethod
    def from_params(cls, context: AppContext, output_dir: Path) -> ReportGenerator:
        """
        Create a ReportGenerator from an application context and a specified output directory.

        Args:
        ----
            context: The application context containing config, logger, and translator.
            output_dir: The directory to store the generated reports.

        Returns:
        -------
            A configured ReportGenerator instance.
        """
        instance = cls(context=context, output_dir=output_dir)
        instance._ensure_output_directory(output_dir)  # noqa: SLF001
        return instance

    def _ensure_output_directory(self, output_dir: Path) -> Path:
        """
        Ensure the output directory exists, creating it if necessary.

        Args:
        ----
            output_dir: The path to the directory to ensure.

        Returns:
        -------
            The path to the ensured output directory.

        Raises:
        ------
            DirectoryCreationError: If the directory cannot be created.
        """
        try:
            output_dir.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            msg = self._(f"Failed to create report directory {output_dir}: {e}")
            raise DirectoryCreationError(msg, original_exception=e) from e
        else:
            return output_dir

    def _validate_results(self, ntp_results: list[str], url_results: list[str]) -> None:
        """
        Validate the NTP and URL results before generating reports.

        Args:
        ----
            ntp_results: A list of NTP test results (strings).
            url_results: A list of URL test results (strings).

        Raises:
        ------
            ReportsMissingDataError: If both ntp_results and url_results are empty.
            TypeError: If ntp_results or url_results are not lists of strings.
        """
        if not ntp_results and not url_results:
            self.logger.error(self._("No results provided for report generation"))
            msg = self._("Cannot generate a report with no results")
            raise ReportsMissingDataError(msg)

        if not all(isinstance(item, str) for item in ntp_results):
            self.logger.error(self._("Invalid NTP results: Expected list of strings"))
            raise TypeError(self._("NTP results must be a list of strings"))

        if not all(isinstance(item, str) for item in url_results):
            self.logger.error(self._("Invalid URL results: Expected list of strings"))
            raise TypeError(self._("URL results must be a list of strings"))

    def generate_report(self, validated_data: ReportInput, report_filename: str = "report.txt") -> Path:
        """
        Generates a physical report based on validated data.

        This method creates a simple text report containing the NTP and URL results.

        Args:
        ----
            validated_data: An instance of `ReportInput` with already validated data.
            report_filename: The name of the report file to be created. Defaults to "report.txt".

        Returns:
        -------
            The path to the created report file.
        """
        report_path = self.output_dir / report_filename
        with open(report_path, "w", encoding="utf-8") as f:
            f.write(self._("Connectivity Report\n\n"))
            f.write(self._("NTP Results:\n"))
            if validated_data.ntp_results:
                for result in validated_data.ntp_results:
                    f.write(f"- {result}\n")
            else:
                f.write(self._("- No NTP results.\n"))

            f.write(self._("\nURL Results:\n"))
            if validated_data.url_results:
                for result in validated_data.url_results:
                    f.write(f"- {result}\n")
            else:
                f.write(self._("- No URL results.\n"))
        self.logger.info(self._("Report saved to: %s"), report_path)
        return report_path

    def generate_reports(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> None:
        """
        Generates both HTML and PDF reports from NTP and URL test results.

        Args:
        ----
            ntp_results: A list of NTP check results.
            url_results: A list of URL check results.
        """
        self.logger.info(self._("Generating reports in %s"), self.output_dir)

        self.generate_html_report(
            ntp_results=ntp_results,
            url_results=url_results,
        )

        self.generate_pdf_report(
            ntp_results=ntp_results,
            url_results=url_results,
        )

    def generate_html_report(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> Path:
        """
        Generate an HTML report from NTP and URL test results.

        Args:
        ----
            ntp_results: List of NTP check results (strings).
            url_results: List of URL check results (strings).

        Returns:
        -------
            Path to the generated HTML report.

        Raises:
        ------
            ValidationError: If the input data fails Pydantic validation.
            OSError: If there is an error writing the HTML file.
            Exception: For any other unexpected errors during report generation.
        """
        self.logger.info(self._("Creating HTML report with NTP servers and URLs from config in %s"), self.output_dir)

        try:
            ReportInput(ntp_results=ntp_results, url_results=url_results)
        except ValidationError as e:
            msg = self._(f"Invalid report data: {e}")
            self.logger.exception(msg)
            raise

        try:
            ntp_content = "\n".join(ntp_results)
            url_content = "\n".join(url_results)

            # Instantiate the template and render the HTML
            report_template = ReportTemplate()
            html_content = report_template.render(ntp_content, url_content)

            # Ensure output directory exists and write the HTML content
            output_path = self.output_dir / self.HTML_FILENAME
            output_path.write_text(html_content, encoding="utf-8")

            self.logger.info(self._("HTML report generated at %s"), str(output_path))

        except (OSError, Exception):
            self.logger.exception(self._("Error generating HTML report."))
            raise
        else:
            return output_path

    def generate_pdf_report(
        self,
        ntp_results: list[str],
        url_results: list[str],
    ) -> Path:
        """
        Generate a PDF report from NTP and URL test results.

        Args:
        ----
            ntp_results: List of NTP check results (strings).
            url_results: List of URL check results (strings).

        Returns:
        -------
            Path to the generated PDF report.

        Raises:
        ------
            ValidationError: If the input data fails Pydantic validation.
            Exception: For any errors during PDF generation via WeasyPrint.
        """
        self.logger.info(self._("Creating PDF report with NTP servers and URLs from config in %s"), self.output_dir)

        try:
            ReportInput(ntp_results=ntp_results, url_results=url_results)
        except ValidationError as e:
            msg = self._(f"Invalid report data: {e}")
            self.logger.exception(msg)
            raise

        try:
            ntp_content = "\n".join(ntp_results)
            url_content = "\n".join(url_results)

            # Instantiate the template and render the HTML
            report_template = ReportTemplate()
            html_content = report_template.render(ntp_content, url_content)

            output_path = self.output_dir / self.PDF_FILENAME

            # Generate the PDF
            HTML(string=html_content).write_pdf(str(output_path))

            self.logger.info(self._("PDF report generated at %s"), str(output_path))

        except Exception:
            self.logger.exception(self._("Error generating PDF report."))
            raise
        else:
            return output_path


def generate_html_report(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate an HTML report from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_html_report(ntp_results, url_results)


def generate_pdf_report(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate a PDF report from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_pdf_report(ntp_results, url_results)


def generate_reports(
    context: AppContext,
    ntp_results: list[str],
    url_results: list[str],
) -> None:
    """
    Generate both HTML and PDF reports from NTP and URL test results using the application context.

    Args:
    ----
        context: Provides config, logger, and translator.
        ntp_results: List of NTP check results.
        url_results: List of URL check results.
    """
    report_generator = ReportGenerator.from_context(context=context)
    report_generator.generate_html_report(ntp_results, url_results)
    report_generator.generate_pdf_report(ntp_results, url_results)
